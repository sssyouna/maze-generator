<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Maze Generator</title>
    <style>
        html, body {
            margin: 0;
            padding: 0;
            font-family: sans-serif;
        }

        body {
            display: flex;
            flex-direction: column;
            align-items: center; 
        }

        #inputs {
            margin-top: 20px;
        }

        #maze-table {
            margin-top: 10px;
            border-collapse: collapse;
            border: 2px solid black;
        }
        
        .solution {
            background-color: rgba(255, 0, 0, 0.5);
        }
    </style>
</head>
<body>
    <div id="inputs">
        <h1>Give the maze dimensions</h1>
        <label>Width: <input type="number" id="w" required></label>
        <label>Height: <input type="number" id="h" required></label>
        <button id="generatebtn">Generate</button>
        <button id="startbtn">Start playing</button>
        <button id="show-solutionbtn">show solution </button>
    </div>

    <table id="maze-table" style="border-collapse: collapse; border: 2px solid black;"></table>

    <script>
        // Global variables for storing maze data and player position
        let currentMazeData = null;
        let currentPlayerPos = null;
        
        // Add event listeners once at the top level
        document.getElementById("generatebtn").addEventListener("click", function() {
                const width = Math.max(2, Math.min(50, parseInt(document.getElementById("w").value)));
                const height = Math.max(2, Math.min(50, parseInt(document.getElementById("h").value)));

                if (!width || !height) {
                    alert("Please enter both width and height");
                    return;
                }

                fetch("/generate", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        width: width,
                        height: height
                    })
                })
                .then(res => res.json())
                .then(data => {
                    currentMazeData = data; // Store for solution
                    drawMaze(data);
                })
                .catch(err => console.error(err));
            });
            
        document.getElementById("show-solutionbtn").addEventListener("click", function() {
            if (currentMazeData) {
                findAndDrawSolution(currentMazeData);
            }
        });
        
        document.getElementById("startbtn").addEventListener("click", function() {
            // Reset the game state but keep the same maze structure
            if (currentMazeData) {
                // Reset player position to end (green) and remove solution path
                drawMaze(currentMazeData);
                // Set initial player position to end point
                currentPlayerPos = {x: currentMazeData.w - 1, y: currentMazeData.h - 1};
                // Update player position visualization
                updatePlayerPosition();
            } else {
                // If no maze exists, generate a default one
                const width = Math.max(2, Math.min(50, parseInt(document.getElementById("w").value)));
                const height = Math.max(2, Math.min(50, parseInt(document.getElementById("h").value)));
                            
                if (!width || !height) {
                    alert("Please enter both width and height");
                    return;
                }
                            
                fetch("/generate", {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        width: width,
                        height: height
                    })
                })
                .then(res => res.json())
                .then(data => {
                    currentMazeData = data; // Store for solution
                    currentPlayerPos = {x: data.w - 1, y: data.h - 1};
                    drawMaze(data);
                    updatePlayerPosition();
                })
                .catch(err => console.error(err));
            }
        });
        
        // Single drawMaze function that only draws the maze
        function drawMaze(data) {
            const { hor, ver, w, h } = data;
            const table = document.getElementById("maze-table");
            table.innerHTML = "";
        
            for (let y = 0; y < h; y++) {
                const tr = document.createElement("tr");
        
                for (let x = 0; x < w; x++) {
                    const td = document.createElement("td");
                    td.id = `cell-${y}-${x}`; // Add unique ID to each cell
                    td.style.width = "25px";
                    td.style.height = "25px";
                    td.style.boxSizing = "border-box";
        
                    // TOP
                    td.style.borderTop = hor[y][x]
                        ? "2px solid black"
                        : "none";
        
                    // BOTTOM
                    td.style.borderBottom = hor[y + 1][x]
                        ? "2px solid black"
                        : "none";
        
                    // LEFT
                    td.style.borderLeft = ver[y][x]
                        ? "2px solid black"
                        : "none";
        
                    // RIGHT
                    td.style.borderRight = ver[y][x + 1]
                        ? "2px solid black"
                        : "none";
        
                    // Entrance / Exit (corrected colors: start=red, end=green)
                    if (x === 0 && y === 0) td.style.background = "lightcoral";  // Start point (red)
                    if (x === w - 1 && y === h - 1) td.style.background = "lightgreen";  // End point (green)
        
                    tr.appendChild(td);
                }
                table.appendChild(tr);
            }
        }
        
        // Function to find and draw solution path
        function findAndDrawSolution(mazeData) {
            const { hor, ver, w, h } = mazeData;
            
            // BFS to find solution path from start (0,0) to end (w-1, h-1)
            const queue = [{x: 0, y: 0, path: [{x: 0, y: 0}]}];
            const visited = Array(h).fill().map(() => Array(w).fill(false));
            visited[0][0] = true;
            
            while (queue.length > 0) {
                const {x, y, path} = queue.shift();
                
                if (x === w - 1 && y === h - 1) {
                    // Found solution path
                    drawSolutionPath(path);
                    return;
                }
                
                // Check all 4 directions
                // Up: check if there's no top wall for current cell
                if (y > 0 && !hor[y][x] && !visited[y-1][x]) {
                    visited[y-1][x] = true;
                    queue.push({x: x, y: y-1, path: [...path, {x: x, y: y-1}] });
                }
                
                // Down: check if there's no bottom wall for current cell
                if (y < h-1 && !hor[y+1][x] && !visited[y+1][x]) {
                    visited[y+1][x] = true;
                    queue.push({x: x, y: y+1, path: [...path, {x: x, y: y+1}] });
                }
                
                // Left: check if there's no left wall for current cell
                if (x > 0 && !ver[y][x] && !visited[y][x-1]) {
                    visited[y][x-1] = true;
                    queue.push({x: x-1, y: y, path: [...path, {x: x-1, y: y}] });
                }
                
                // Right: check if there's no right wall for current cell
                if (x < w-1 && !ver[y][x+1] && !visited[y][x+1]) {
                    visited[y][x+1] = true;
                    queue.push({x: x+1, y: y, path: [...path, {x: x+1, y: y}] });
                }
            }
            
            console.log("No solution found");
        }
        
        // Function to draw the solution path
        function drawSolutionPath(path) {
            // Reset all cell backgrounds first
            const table = document.getElementById("maze-table");
            const rows = table.querySelectorAll("tr");
            
            for (let y = 0; y < rows.length; y++) {
                const cells = rows[y].querySelectorAll("td");
                for (let x = 0; x < cells.length; x++) {
                    // Reset to default (might have been highlighted before)
                    if (!(x === 0 && y === 0) && !(x === currentMazeData.w - 1 && y === currentMazeData.h - 1)) {
                        if (cells[x].style.background !== "lightgreen" && cells[x].style.background !== "lightcoral") {
                            cells[x].style.background = "";
                        }
                    }
                }
            }
            
            // Highlight the solution path in red
            for (const pos of path) {
                const cell = document.getElementById(`cell-${pos.y}-${pos.x}`);  // Use ID to get cell
                if (cell) {
                    // Don't override entrance/exit colors
                    if (!(pos.x === 0 && pos.y === 0) && !(pos.x === currentMazeData.w - 1 && pos.y === currentMazeData.h - 1)) {
                        cell.classList.add("solution");  // Add CSS class for solution path
                    }
                }
            }
        }
        
        // Function to update player position visualization
        function updatePlayerPosition(prevX = -1, prevY = -1) {
            if (!currentMazeData || !currentPlayerPos) return;
            
            const { w, h } = currentMazeData;
            const { x, y } = currentPlayerPos;
            
            // Validate position is within bounds
            if (x < 0 || x >= w || y < 0 || y >= h) return;
            
            // Clear previous player position if provided
            if (prevX !== -1 && prevY !== -1) {
                const prevCell = document.getElementById(`cell-${prevY}-${prevX}`);
                if (prevCell) {
                    // Only clear if the previous cell is not the start or end point
                    if (prevX === 0 && prevY === 0) {
                        prevCell.style.background = "lightcoral"; // Start point stays red
                    } else if (prevX === w - 1 && prevY === h - 1) {
                        prevCell.style.background = "lightgreen"; // End point stays green
                    } else {
                        // Clear the background if it's just a regular path cell
                        prevCell.style.background = "";
                    }
                }
            }
            
            // Get the current cell element
            const cell = document.getElementById(`cell-${y}-${x}`);
            if (cell) {
                // Add player indicator (different from start/end)
                cell.style.background = "radial-gradient(circle, yellow, gold)";
            }
            
            // Make sure start and end points retain their colors if they are not the current player position
            if (!(x === 0 && y === 0)) {
                const startCell = document.getElementById(`cell-0-0`);
                if (startCell) startCell.style.background = "lightcoral";
            }
            if (!(x === w - 1 && y === h - 1)) {
                const endCell = document.getElementById(`cell-${h-1}-${w-1}`);
                if (endCell) endCell.style.background = "lightgreen";
            }
        }
        
        // Keyboard controls for player movement
        document.addEventListener('keydown', function(e) {
            if (!currentMazeData || !currentPlayerPos) return;
            
            const { hor, ver, w, h } = currentMazeData;
            let { x, y } = currentPlayerPos;
            let moved = false;
            
            switch(e.key) {
                case 'ArrowUp':
                    if (y > 0 && !hor[y][x]) { // Check if no top wall
                        y--;
                        moved = true;
                    }
                    break;
                case 'ArrowDown':
                    if (y < h - 1 && !hor[y + 1][x]) { // Check if no bottom wall
                        y++;
                        moved = true;
                    }
                    break;
                case 'ArrowLeft':
                    if (x > 0 && !ver[y][x]) { // Check if no left wall
                        x--;
                        moved = true;
                    }
                    break;
                case 'ArrowRight':
                    if (x < w - 1 && !ver[y][x + 1]) { // Check if no right wall
                        x++;
                        moved = true;
                    }
                    break;
            }
            
            if (moved) {
                // Track previous position
                const prevX = currentPlayerPos.x;
                const prevY = currentPlayerPos.y;
                
                // Update player position
                currentPlayerPos = { x, y };
                
                // Update visualization with previous position
                updatePlayerPosition(prevX, prevY);
                
                // Check if player reached start point (win condition)
                if (x === 0 && y === 0) {
                    setTimeout(() => {
                        findAndDrawSolution(currentMazeData);
                        alert('Congratulations! You reached the start point!');
                    }, 100);
                }
            }
        });
    </script>
</body>
</html>
